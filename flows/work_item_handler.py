"""
Work Item Handler Pattern for Different Work Item Types.

This module provides a flexible framework for handling different work item types
(Glass, PM, Brake, etc.) with their specific workflows while sharing common logic.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Dict, Any
from utils.logger import log

@dataclass
class WorkItemConfig:
    """Configuration data for creating work items from CSV data."""
    mva: str
    damage_type: Optional[str] = None
    location: Optional[str] = None
    
    def __post_init__(self):
        """Validate and normalize config data."""
        self.mva = self.mva.strip()
        if self.damage_type:
            self.damage_type = self.damage_type.strip().upper()
        if self.location:
            self.location = self.location.strip().upper()

class WorkItemHandler(ABC):
    """Abstract base class for work item creation handlers."""
    
    def __init__(self, driver):
        """Initialize handler with WebDriver instance."""
        self.driver = driver
    
    @abstractmethod
    def get_work_item_type(self) -> str:
        """Return the work item type identifier (e.g., 'GLASS', 'PM')."""
        pass
    
    @abstractmethod
    def should_handle_existing_complaint(self, complaint_text: str) -> bool:
        """Determine if an existing complaint matches this work item type."""
        pass
    
    @abstractmethod
    def create_new_complaint(self, config: WorkItemConfig) -> Dict[str, Any]:
        """Create a new complaint for this work item type."""
        pass
    
    @abstractmethod
    def handle_existing_complaint(self, config: WorkItemConfig, complaint_element) -> Dict[str, Any]:
        """Handle workflow when existing complaint is found."""
        pass
    
    # ----------------------------------------------------------------------------
    # AUTHOR:       Dirk Steele <dirk.avis@gmail.com>
    # DATE:         2026-01-12
    # DESCRIPTION:  Main entry point for creating work items using this handler.
    #               Orchestrates the common workflow: click Add Work Item, check for
    #               existing complaints, associate or create complaint, and complete
    #               work item-specific steps.
    # VERSION:      1.0.0
    # NOTES:        Used by all handler subclasses.
    # ----------------------------------------------------------------------------
    def create_work_item(self, config: WorkItemConfig) -> Dict[str, Any]:
        log.info(f"[WORKITEM] {config.mva} - Creating {self.get_work_item_type()} work item")
        # Step 1: Click Add Work Item button (common for all types)
        if not self._click_add_work_item_button(config):
            return {"status": "failed", "reason": "add_btn", "mva": config.mva}
        # Step 2: Handle complaint logic (type-specific)
        return self._handle_complaint_flow(config)
    
    # ----------------------------------------------------------------------------
    # AUTHOR:       Dirk Steele <dirk.avis@gmail.com>
    # DATE:         2026-01-12
    # DESCRIPTION:  Click the Add Work Item button. Common implementation for all handlers.
    # VERSION:      1.0.0
    # NOTES:        Waits for button, logs result, and handles exceptions.
    # ----------------------------------------------------------------------------
    def _click_add_work_item_button(self, config: WorkItemConfig) -> bool:
        from utils.ui_helpers import click_element
        from selenium.webdriver.common.by import By
        import time
        try:
            time.sleep(5)  # wait for button to appear
            if not click_element(self.driver, 
                               (By.XPATH, "//button[normalize-space()='Add Work Item']"), 
                               timeout=30, 
                               desc="Add Work Item button"):
                log.warning(f"[WORKITEM][WARN] {config.mva} - add_btn not found")
                return False
            log.info(f"[WORKITEM] {config.mva} - Add Work Item clicked")
            time.sleep(5)
            return True
        except Exception as e:
            log.warning(f"[WORKITEM][WARN] {config.mva} - add_btn failed -> {e}")
            return False
    
    # ----------------------------------------------------------------------------
    # AUTHOR:       Dirk Steele <dirk.avis@gmail.com>
    # DATE:         2026-01-12
    # DESCRIPTION:  Handle the complaint association/creation flow. Checks for existing
    #               complaints, delegates to handler or creates new complaint as needed.
    # VERSION:      1.0.0
    # NOTES:        Used by all handler subclasses.
    # ----------------------------------------------------------------------------
    def _handle_complaint_flow(self, config: WorkItemConfig) -> Dict[str, Any]:
        from flows.complaints_flows import detect_existing_complaints
        try:
            # Check for existing complaints that match this work item type
            existing_complaints = detect_existing_complaints(self.driver, config.mva)
            for complaint in existing_complaints:
                if self.should_handle_existing_complaint(complaint.text):
                    log.info(f"[{self.get_work_item_type()}] {config.mva} - Found matching existing complaint")
                    return self.handle_existing_complaint(config, complaint)
            # No matching complaint found, create new one
            log.info(f"[{self.get_work_item_type()}] {config.mva} - No matching complaint found, creating new one")
            return self.create_new_complaint(config)
        except Exception as e:
            log.warning(f"[WORKITEM][WARN] {config.mva} - complaint handling failed -> {e}")
            return {"status": "failed", "reason": "complaint_handling", "mva": config.mva}

class GlassWorkItemHandler(WorkItemHandler):
    """Handler for Glass damage work items."""
    # UI text mappings for glass damage types (captured from actual UI)
    DAMAGE_TYPE_MAPPINGS = {
        "REPLACEMENT": "Replace",  # TODO: Capture exact UI text during iteration
        "CRACK": "Crack",         # TODO: Capture exact UI text during iteration  
        "CHIP": "Chip"            # TODO: Capture exact UI text during iteration
    }
    
    # UI text mappings for glass locations (captured from actual UI)
    LOCATION_MAPPINGS = {
        "WINDSHIELD": "Windshield",  # TODO: Capture exact UI text during iteration
        "REAR": "Rear",              # TODO: Capture exact UI text during iteration
        "SIDE": "Side"               # TODO: Capture exact UI text during iteration
    }
    
    def get_work_item_type(self) -> str:
        """Return the work item type identifier."""
        return "GLASS"
    
    def should_handle_existing_complaint(self, complaint_text: str) -> bool:
        """
        Determine if existing complaint is glass-related.
        Look for glass keywords in complaint text.
        """
        glass_keywords = ["glass", "windshield", "crack", "chip", "replace"]
        complaint_lower = complaint_text.lower()
        return any(keyword in complaint_lower for keyword in glass_keywords)
    
    # ----------------------------------------------------------------------------
    # AUTHOR:       Dirk Steele <dirk.avis@gmail.com>
    # DATE:         2026-01-12
    # DESCRIPTION:  Create new glass complaint. Handles UI flow for glass complaint
    #               creation, including damage type and location selection.
    # VERSION:      1.0.0
    # NOTES:        TODO: Add UI logic for damage type/location selection.
    # ----------------------------------------------------------------------------
    def create_new_complaint(self, config: WorkItemConfig) -> Dict[str, Any]:
        from flows.complaints_flows import create_new_complaint
        # For now, delegate to existing create_new_complaint with glass type
        # TODO: Update create_new_complaint to accept damage_type and location parameters
        result = create_new_complaint(self.driver, config.mva, complaint_type="glass")
        if result.get("status") == "created":
            log.info(f"[GLASS] {config.mva} - New glass complaint created")
            # TODO: Add damage type and location selection logic here
            # This will need to interact with the glass complaint UI to select:
            # - Damage type from config.damage_type using DAMAGE_TYPE_MAPPINGS
            # - Location from config.location using LOCATION_MAPPINGS
        return result
    
    # ----------------------------------------------------------------------------
    # AUTHOR:       Dirk Steele <dirk.avis@gmail.com>
    # DATE:         2026-01-12
    # DESCRIPTION:  Handle existing glass complaint scenarios. Associates complaint,
    #               manages UI flow for repair/replacement, mileage, and OpCode.
    # VERSION:      1.0.0
    # NOTES:        TODO: Add UI logic for work item type, mileage, and OpCode.
    # ----------------------------------------------------------------------------
    def handle_existing_complaint(self, config: WorkItemConfig, complaint_element) -> Dict[str, Any]:
        from flows.complaints_flows import associate_existing_complaint
        from flows.finalize_flow import finalize_workitem
        try:
            # Associate the existing complaint
            result = associate_existing_complaint(self.driver, config.mva)
            if result.get("status") == "associated":
                log.info(f"[GLASS] {config.mva} - Existing glass complaint associated")
                # TODO: Add logic to handle work item type selection for replacement
                # If config.damage_type == "REPLACEMENT", need to select "Replace" option
                # TODO: Add mileage handling
                # TODO: Add OpCode selection ("Glass Repair/Replace")
                # For now, return success placeholder
                return {"status": "created", "mva": config.mva}
            else:
                log.warning(f"[GLASS] {config.mva} - Failed to associate existing complaint")
                return result
        except Exception as e:
            log.error(f"[GLASS] {config.mva} - Error handling existing complaint: {e}")
            return {"status": "failed", "reason": "existing_complaint_error", "mva": config.mva}

# Handler factory for future expansion
def create_work_item_handler(work_item_type: str, driver) -> WorkItemHandler:
    """
    Factory function to create appropriate work item handler.
    
    Args:
        work_item_type: Type identifier (inferred from script context)
        driver: WebDriver instance
    Returns:
        Appropriate handler instance
    """
    if work_item_type.upper() == "GLASS":
        return GlassWorkItemHandler(driver)
    # TODO: Add other handler types as needed
    # elif work_item_type.upper() == "PM":
    #     return PMWorkItemHandler(driver)
    else:
        raise ValueError(f"Unsupported work item type: {work_item_type}")
